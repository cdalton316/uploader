const {
  S3Client,
  GetObjectCommand,
  PutObjectCommand,
} = require("@aws-sdk/client-s3");
const sharp = require("sharp");

const s3Client = new S3Client({
  region: process.env.AWS_REGION || "us-east-1",
});
const SOURCE_BUCKET = "uploader-cdalton";
const DEST_BUCKET = "uploader-downloads-briefly2";

exports.handler = async (event) => {
  console.log("Received event:", JSON.stringify(event, null, 2));

  // Process each SQS record
  for (const record of event.Records) {
    try {
      // Parse the SQS message body (which contains the S3 event)
      const s3Event = JSON.parse(record.body);

      // Handle S3 event notifications
      if (s3Event.Records && Array.isArray(s3Event.Records)) {
        for (const s3Record of s3Event.Records) {
          await processS3Record(s3Record);
        }
      } else if (s3Event.s3) {
        // If the message body is already the S3 record
        await processS3Record(s3Event);
      }
    } catch (error) {
      console.error("Error processing record:", error);
      // Continue processing other records even if one fails
    }
  }

  return {
    statusCode: 200,
    body: JSON.stringify({ message: "Processing completed" }),
  };
};

async function processS3Record(s3Record) {
  try {
    const bucket = s3Record.s3.bucket.name;
    const key = decodeURIComponent(s3Record.s3.object.key.replace(/\+/g, " "));

    console.log(`Processing file: ${bucket}/${key}`);

    // Skip if not an image file
    if (!isImageFile(key)) {
      console.log(`Skipping non-image file: ${key}`);
      return;
    }

    // Download the image from S3
    const getObjectCommand = new GetObjectCommand({
      Bucket: bucket,
      Key: key,
    });

    const response = await s3Client.send(getObjectCommand);
    const imageBuffer = await streamToBuffer(response.Body);

    // Add watermark to the image
    const watermarkedImage = await addWatermark(imageBuffer);

    // Upload watermarked image to destination bucket
    const destKey = key; // Keep the same key structure
    const putObjectCommand = new PutObjectCommand({
      Bucket: DEST_BUCKET,
      Key: destKey,
      Body: watermarkedImage,
      ContentType: response.ContentType || "image/jpeg",
    });

    await s3Client.send(putObjectCommand);
    console.log(`Successfully processed and uploaded: ${destKey}`);
  } catch (error) {
    console.error(`Error processing S3 record:`, error);
    throw error;
  }
}

async function addWatermark(imageBuffer) {
  try {
    // Get image metadata
    const metadata = await sharp(imageBuffer).metadata();
    const { width, height } = metadata;

    // Create watermark text SVG
    const watermarkText = "briefly.dev";
    const fontSize = Math.max(24, Math.floor(width / 20)); // Responsive font size
    const padding = 20;

    const svgWatermark = `
      <svg width="${width}" height="${height}">
        <text
          x="${width - padding}"
          y="${height - padding}"
          font-family="Arial, sans-serif"
          font-size="${fontSize}"
          font-weight="bold"
          fill="rgba(255, 255, 255, 0.8)"
          text-anchor="end"
          dominant-baseline="baseline"
          stroke="rgba(0, 0, 0, 0.5)"
          stroke-width="1"
        >${watermarkText}</text>
      </svg>
    `;

    // Composite the watermark onto the image
    const watermarked = await sharp(imageBuffer)
      .composite([
        {
          input: Buffer.from(svgWatermark),
          gravity: "southeast", // Bottom right corner
        },
      ])
      .toBuffer();

    return watermarked;
  } catch (error) {
    console.error("Error adding watermark:", error);
    throw error;
  }
}

function isImageFile(key) {
  const imageExtensions = [
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".webp",
    ".bmp",
    ".tiff",
  ];
  const lowerKey = key.toLowerCase();
  return imageExtensions.some((ext) => lowerKey.endsWith(ext));
}

async function streamToBuffer(stream) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    stream.on("data", (chunk) => chunks.push(chunk));
    stream.on("error", reject);
    stream.on("end", () => resolve(Buffer.concat(chunks)));
  });
}
